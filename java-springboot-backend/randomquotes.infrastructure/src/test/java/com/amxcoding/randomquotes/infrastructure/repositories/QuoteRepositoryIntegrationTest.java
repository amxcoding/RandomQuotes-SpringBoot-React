// TODO FIX:
//package com.amxcoding.randomquotes.infrastructure.repositories;
//
//import com.amxcoding.randomquotes.application.interfaces.repositories.IQuoteRepository;
//import com.amxcoding.randomquotes.domain.entities.Quote;
//import com.amxcoding.randomquotes.infrastructure.persistence.models.QuoteEntity;
//import org.junit.jupiter.api.*;
//import org.slf4j.Logger;
//import org.slf4j.LoggerFactory;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.boot.test.autoconfigure.data.r2dbc.DataR2dbcTest;
//import org.springframework.context.annotation.Import;
//import org.springframework.data.r2dbc.core.R2dbcEntityTemplate;
//import org.springframework.r2dbc.core.DatabaseClient;
//import org.springframework.test.context.DynamicPropertyRegistry;
//import org.springframework.test.context.DynamicPropertySource;
//import reactor.core.publisher.Flux;
//import reactor.core.publisher.Mono;
//import reactor.test.StepVerifier;
//
//import java.util.List;
//import java.util.Optional;
//
//import static org.assertj.core.api.Assertions.assertThat;
//import static org.springframework.data.relational.core.query.Criteria.where;
//import static org.springframework.data.relational.core.query.Query.query;
//
//@DataR2dbcTest
//@Import(QuoteRepository.class)
//@TestInstance(TestInstance.Lifecycle.PER_CLASS)
//@TestMethodOrder(MethodOrderer.DisplayName.class)
//@DisplayName("QuoteRepositoryIntegrationTests (H2)")
//class QuoteRepositoryIntegrationTest {
//
//    private static final Logger log = LoggerFactory.getLogger(QuoteRepositoryIntegrationTest.class);
//
//    @Autowired
//    private IQuoteRepository quoteRepository;
//    @Autowired
//    private DatabaseClient databaseClient;
//    @Autowired
//    private R2dbcEntityTemplate entityTemplate;
//
//    private final Quote quote1Input = new Quote("Integration Author 1", "Integration Text 1");
//    private final Quote quote2Input = new Quote("Integration Author 2", "Integration Text 2");
//    private final Quote quote1DuplicateInput = new Quote("Integration Author 1", "Integration Text 1");
//    private final String testProvider = "test-suite";
//
//    // Enable H2 PostgreSQL compatibility mode for ON CONFLICT syntax support
//    // and prevent uppercasing of identifiers which can interfere with Spring Data R2DBC.
//    @DynamicPropertySource
//    static void h2Properties(DynamicPropertyRegistry registry) {
//        log.info("--- Applying Dynamic Properties for H2 PG Mode ---");
//        registry.add("spring.r2dbc.url", () -> "r2dbc:h2:mem:///testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_UPPER=FALSE");
//        registry.add("spring.r2dbc.username", () -> "sa");
//        registry.add("spring.r2dbc.password", () -> "");
//        registry.add("spring.sql.init.mode", () -> "never");
//    }
//
//    @BeforeAll
//    void initializeDatabaseSchema() {
//        log.info("--- (BeforeAll) Initializing Database Schema ---");
//        String createQuotesTableSql = """
//            CREATE TABLE IF NOT EXISTS quotes (
//                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
//                author VARCHAR(125) NOT NULL,
//                text TEXT NOT NULL,
//                likes INTEGER NOT NULL DEFAULT 0,
//                text_author_hash VARCHAR(255) NOT NULL UNIQUE,
//                provider VARCHAR(100) NOT NULL
//            );
//            """;
//        String createQuoteLikeTableSql = """
//            CREATE TABLE IF NOT EXISTS quote_like (
//                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
//                user_id VARCHAR(64) NOT NULL,
//                quote_id BIGINT NOT NULL,
//                liked_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
//                CONSTRAINT fk_quote FOREIGN KEY(quote_id) REFERENCES quotes(id) ON DELETE CASCADE,
//                CONSTRAINT uk_user_quote UNIQUE (user_id, quote_id)
//            );
//            """;
//        String createQuoteLikeIndexSql = """
//            CREATE INDEX IF NOT EXISTS idx_quote_like_user_id ON quote_like(user_id);
//            """;
//
//        // Execute schema creation sequentially. Block ensures completion before tests start.
//        databaseClient.sql(createQuotesTableSql).then()
//                .then(databaseClient.sql(createQuoteLikeTableSql).then())
//                .then(databaseClient.sql(createQuoteLikeIndexSql).then())
//                .block();
//        log.info("--- (BeforeAll) Database Schema Initialized ---");
//    }
//
//    @BeforeEach
//    void resetDatabaseTables() {
//        log.debug("--- (BeforeEach) Resetting Database Tables ---");
//        String deleteLikesSql = "DELETE FROM quote_like";
//        String deleteQuotesSql = "DELETE FROM quotes";
//
//        databaseClient.sql(deleteLikesSql).then() // Delete from quote_like first
//                .then(databaseClient.sql(deleteQuotesSql).then()) // Then delete from quotes
//                .block(); // Block until cleanup is complete before the test runs
//        log.debug("--- (BeforeEach) Database Tables Reset ---");
//    }
//
//    @AfterAll
//    void tearDownDatabase() {
//        log.info("--- (AfterAll) Performing Final Cleanup ---");
//         databaseClient.sql("DROP TABLE IF EXISTS quote_like").then()
//                 .then(databaseClient.sql("DROP TABLE IF EXISTS quotes").then())
//                 .block();
//         log.info("--- (AfterAll) Final Cleanup Complete ---");
//    }
//
//
//    /**
//     * Helper to directly find a QuoteEntity by ID using R2dbcEntityTemplate.
//     * Useful for asserting database state changes.
//     */
//    private Mono<QuoteEntity> findEntityById(Long id) {
//        if (id == null) {
//            return Mono.error(new IllegalArgumentException("Cannot find entity with null ID"));
//        }
//        return entityTemplate.selectOne(
//                query(where("id").is(id)),
//                QuoteEntity.class
//        );
//    }
//
//    /**
//     * Helper to insert a single quote entity using R2dbcEntityTemplate
//     * and then retrieve the persisted Quote domain object (with its assigned ID).
//     * Essential for setting up state in tests that require a persisted quote.
//     * Uses a direct entity insert instead of the repository's bulk method for setup reliability.
//     */
//    private Mono<Quote> insertAndRetrieve(Quote quoteInput, String provider) {
//        QuoteEntity entityToInsert = new QuoteEntity();
//        entityToInsert.setAuthor(quoteInput.getAuthor());
//        entityToInsert.setText(quoteInput.getText());
//        entityToInsert.setLikes(quoteInput.getLikes());
//        entityToInsert.setTextAuthorHash(quoteInput.generateTextAuthorHash());
//        entityToInsert.setProvider(provider);
//
//        return entityTemplate.insert(entityToInsert)
//                // Map the persisted entity back to the domain Quote object.
//                .map(persistedEntity -> {
//                    // Ensure the ID is populated before creating the domain object
//                    assertThat(persistedEntity.getId()).isNotNull();
//                    return new Quote(
//                            persistedEntity.getId(),
//                            persistedEntity.getAuthor(),
//                            persistedEntity.getText(),
//                            persistedEntity.getLikes()
//                    );
//                });
//    }
//
//    /**
//     * Helper to count the total number of quotes in the database directly.
//     */
//    private Mono<Long> countQuotesInDb() {
//        return databaseClient
//                .sql("SELECT COUNT(*) FROM quotes")
//                .map(row -> row.get(0, Long.class)) // Extract count from the first column
//                .one() // Expect exactly one row (the count)
//                .defaultIfEmpty(0L); // Return 0 if the table is empty/query returns nothing
//    }
//
//
//    @Nested
//    @DisplayName("findById() Integration Tests")
//    class FindByIdTests {
//
//        @Test
//        @DisplayName("1. Should return Optional containing the quote when ID exists")
//        void findById_whenFound_shouldReturnOptionalWithQuote() {
//            // Arrange: Insert a quote using the *fixed* helper to get a valid ID.
//            Quote savedQuote = insertAndRetrieve(quote1Input, testProvider + "-findById-found").block();
//            assertThat(savedQuote).isNotNull(); // Sanity check: Ensure setup insertion worked
//            Long existingId = savedQuote.getId();
//            assertThat(existingId).isNotNull(); // Sanity check: ID must be generated
//
//            // Act: Call the repository method under test.
//            Mono<Optional<Quote>> resultMono = quoteRepository.findById(existingId);
//
//            // Assert: Verify the Optional contains the correct quote data retrieved by findById.
//            StepVerifier.create(resultMono)
//                    .assertNext(optionalQuote -> {
//                        assertThat(optionalQuote).as("Check if Optional is present").isPresent();
//                        optionalQuote.ifPresent(q -> {
//                            assertThat(q.getId()).as("Check ID").isEqualTo(existingId);
//                            assertThat(q.getAuthor()).as("Check Author").isEqualTo(quote1Input.getAuthor());
//                            assertThat(q.getText()).as("Check Text").isEqualTo(quote1Input.getText());
//                            assertThat(q.getLikes()).as("Check Likes").isZero(); // Assuming initial likes are 0
//                        });
//                    })
//                    .verifyComplete();
//        }
//
//        @Test
//        @DisplayName("2. Should return empty Optional when ID does not exist")
//        void findById_whenNotFound_shouldReturnEmptyOptional() {
//            // Arrange: Define an ID that is guaranteed not to exist in the clean database.
//            Long nonExistentId = 9999L;
//
//            // Act: Call the repository method under test with the non-existent ID.
//            Mono<Optional<Quote>> resultMono = quoteRepository.findById(nonExistentId);
//
//            // Assert: Verify the Optional returned by the repository is empty.
//            StepVerifier.create(resultMono)
//                    .assertNext(optionalQuote -> {
//                        assertThat(optionalQuote).as("Check if Optional is empty").isNotPresent();
//                    })
//                    .verifyComplete();
//        }
//    }
//
//    @Nested
//    @DisplayName("findByTextAuthorHash() Integration Tests")
//    class FindByHashTests {
//
//        @Test
//        @DisplayName("1. Should return Optional containing the quote when hash matches")
//        void findByTextAuthorHash_whenFound_shouldReturnOptionalWithQuote() {
//            // Arrange: Insert a quote and get its data (including ID) and calculate its hash
//            Quote savedQuote = insertAndRetrieve(quote1Input, testProvider + "-findByHash-found").block();
//            assertThat(savedQuote).isNotNull();
//            assertThat(savedQuote.getId()).isNotNull();
//            String existingHash = quote1Input.generateTextAuthorHash(); // Hash based on original input
//
//            // Act: Call the repository method under test using the hash
//            Mono<Optional<Quote>> resultMono = quoteRepository.findByTextAuthorHash(existingHash);
//
//            // Assert: Verify the Optional contains the quote matching the hash
//            StepVerifier.create(resultMono)
//                    .assertNext(optionalQuote -> {
//                        assertThat(optionalQuote).isPresent();
//                        optionalQuote.ifPresent(q -> {
//                            assertThat(q.getId()).isEqualTo(savedQuote.getId()); // Check ID matches inserted one
//                            assertThat(q.getAuthor()).isEqualTo(quote1Input.getAuthor());
//                            assertThat(q.getText()).isEqualTo(quote1Input.getText());
//                        });
//                    })
//                    .verifyComplete();
//        }
//
//        @Test
//        @DisplayName("2. Should return empty Optional when hash does not exist")
//        void findByTextAuthorHash_whenNotFound_shouldReturnEmptyOptional() {
//            // Arrange: Define a hash that is guaranteed not to exist
//            String nonExistentHash = "non_existent_hash_value_" + System.currentTimeMillis(); // Ensure uniqueness
//
//            // Act: Call the repository method under test
//            Mono<Optional<Quote>> resultMono = quoteRepository.findByTextAuthorHash(nonExistentHash);
//
//            // Assert: Verify the Optional is empty
//            StepVerifier.create(resultMono)
//                    .assertNext(optionalQuote -> assertThat(optionalQuote).isNotPresent())
//                    .verifyComplete();
//        }
//    }
//
//    @Nested
//    @DisplayName("bulkInsertQuotesIgnoreConflicts() Integration Tests")
//    class BulkInsertTests {
//
//        // --- IMPORTANT NOTE ---
//        // The following tests verify the behavior of 'ON CONFLICT ... DO NOTHING'.
//        // This specific SQL syntax is NOT fully supported by H2 database even in
//        // PostgreSQL compatibility mode
//        // These tests are DISABLED when running against H2 and should ideally be
//        // executed against a real PostgreSQL instance (e.g., using Testcontainers)
//        // to ensure correctness.
//
//        @Test
//        @Disabled("H2 does not fully support 'ON CONFLICT DO NOTHING' syntax used by this method.")
//        @DisplayName("1. [DISABLED on H2] Should insert multiple distinct quotes successfully")
//        void bulkInsert_whenMultipleDistinct_shouldInsertAll() {
//            // Arrange: Prepare a list of distinct quotes to be inserted.
//            String provider = testProvider + "-bulkDistinct";
//            List<Quote> quotesToInsert = List.of(quote1Input, quote2Input);
//
//            // Act: Call the bulk insert method which generates 'ON CONFLICT' SQL.
//            Mono<Void> resultMono = quoteRepository.bulkInsertQuotesIgnoreConflicts(quotesToInsert, provider);
//
//            // Assert: Verify the operation completes without error and check the database state.
//            StepVerifier.create(resultMono)
//                    .as("Verify bulk insert completes successfully")
//                    .verifyComplete();
//
//            // Verify count using DB helper
//            StepVerifier.create(countQuotesInDb())
//                    .as("Verify database contains exactly 2 quotes")
//                    .expectNext(2L)
//                    .verifyComplete();
//
//            // Verify individual quotes were inserted using the repository find method
//            StepVerifier.create(quoteRepository.findByTextAuthorHash(quote1Input.generateTextAuthorHash()))
//                    .as("Verify quote 1 exists")
//                    .expectNextMatches(Optional::isPresent)
//                    .verifyComplete();
//            StepVerifier.create(quoteRepository.findByTextAuthorHash(quote2Input.generateTextAuthorHash()))
//                    .as("Verify quote 2 exists")
//                    .expectNextMatches(Optional::isPresent)
//                    .verifyComplete();
//        }
//
//        @Test
//        @Disabled("H2 does not fully support 'ON CONFLICT DO NOTHING' syntax used by this method.")
//        @DisplayName("2. [DISABLED on H2] Should insert new quotes and ignore existing duplicates based on hash")
//        void bulkInsert_whenMixNewAndDuplicate_shouldInsertNewAndIgnoreExisting() {
//            // Arrange: Insert one quote initially to create a duplicate scenario.
//            String provider = testProvider + "-bulkMix";
//            Quote existingQuote = insertAndRetrieve(quote1Input, provider).block(); // Use reliable helper for setup
//            assertThat(existingQuote).isNotNull();
//            List<Quote> quotesToInsert = List.of(quote1DuplicateInput, quote2Input);
//
//            // Act: Call bulk insert with the mixed list (duplicate + new).
//            Mono<Void> resultMono = quoteRepository.bulkInsertQuotesIgnoreConflicts(quotesToInsert, provider);
//
//            // Assert: Verify completion and that only the new quote was added.
//            StepVerifier.create(resultMono)
//                    .as("Verify bulk insert completes successfully")
//                    .verifyComplete();
//
//            // Verify total count is 2 (original quote1 + new quote2; duplicate quote1 was ignored)
//            StepVerifier.create(countQuotesInDb())
//                    .as("Verify database contains exactly 2 unique quotes")
//                    .expectNext(2L)
//                    .verifyComplete();
//
//            // Verify both unique quotes exist
//            StepVerifier.create(quoteRepository.findByTextAuthorHash(quote1Input.generateTextAuthorHash()))
//                    .as("Verify original quote 1 still exists")
//                    .expectNextMatches(Optional::isPresent)
//                    .verifyComplete();
//            StepVerifier.create(quoteRepository.findByTextAuthorHash(quote2Input.generateTextAuthorHash()))
//                    .as("Verify new quote 2 now exists")
//                    .expectNextMatches(Optional::isPresent)
//                    .verifyComplete();
//        }
//
//        @Test
//        @DisplayName("3. Should do nothing and complete successfully when inserting an empty list")
//        void bulkInsert_whenEmptyList_shouldCompleteWithoutChanges() {
//            // Arrange: Prepare an empty list. DB is empty. This case does not hit the DB.
//            String provider = testProvider + "-bulkEmpty";
//            List<Quote> emptyList = List.of();
//
//            // Act: Call bulk insert with the empty list.
//            Mono<Void> resultMono = quoteRepository.bulkInsertQuotesIgnoreConflicts(emptyList, provider);
//
//            // Assert: Verify the operation completes immediately (due to empty list check)
//            // and the database remains empty.
//            StepVerifier.create(resultMono)
//                    .as("Verify bulk insert completes successfully for empty list")
//                    .verifyComplete();
//
//            // Verify database count is still 0
//            StepVerifier.create(countQuotesInDb())
//                    .as("Verify database remains empty")
//                    .expectNext(0L)
//                    .verifyComplete();
//        }
//
//        @Test
//        @Disabled("H2 does not fully support 'ON CONFLICT DO NOTHING' syntax used by this method.")
//        @DisplayName("4. [DISABLED on H2] Should ignore all quotes if they are all duplicates")
//        void bulkInsert_whenAllDuplicates_shouldIgnoreAllAndComplete() {
//            // Arrange: Insert initial quotes using the reliable helper.
//            String provider = testProvider + "-bulkDuplicates";
//            insertAndRetrieve(quote1Input, provider).block();
//            insertAndRetrieve(quote2Input, provider).block();
//            // Prepare list containing only duplicates of existing quotes
//            List<Quote> duplicateList = List.of(quote1DuplicateInput, new Quote(quote2Input.getAuthor(), quote2Input.getText()));
//
//
//            // Act: Call bulk insert with the list containing only duplicates.
//            Mono<Void> resultMono = quoteRepository.bulkInsertQuotesIgnoreConflicts(duplicateList, provider);
//
//            // Assert: Verify the operation completes and the database count remains unchanged.
//            StepVerifier.create(resultMono)
//                    .as("Verify bulk insert completes successfully for all duplicates")
//                    .verifyComplete();
//
//            // Count should still be 2, as all attempted inserts were ignored due to conflict.
//            StepVerifier.create(countQuotesInDb())
//                    .as("Verify database count remains 2 (no new quotes added)")
//                    .expectNext(2L)
//                    .verifyComplete();
//        }
//    }
//
//    @Nested
//    @DisplayName("incrementLikeCount() / decrementLikeCount() Integration Tests")
//    class LikeCounterTests {
//
//        /**
//         * Helper specific to this nested class to set up a quote with 0 likes.
//         * Returns the ID of the newly inserted quote.
//         */
//        private Long setupQuoteAndGetId() {
//            // Arrange Step within Helper: Insert a unique quote for the like test
//            Quote likeTestQuote = new Quote("Like Counter Author", "Like Counter Text " + System.currentTimeMillis());
//            Quote saved = insertAndRetrieve(likeTestQuote, testProvider + "-likesSetup").block();
//
//            // Sanity check the setup
//            assertThat(saved).isNotNull();
//            Long id = saved.getId();
//            assertThat(id).isNotNull();
//
//            // Verify initial likes are 0 directly from DB
//            StepVerifier.create(findEntityById(id))
//                    .assertNext(entity -> assertThat(entity.getLikes()).isZero())
//                    .verifyComplete();
//            return id;
//        }
//
//        @Test
//        @DisplayName("1. incrementLikeCount should increase likes by 1 and return true")
//        void incrementLikeCount_whenQuoteExists_shouldIncrementLikesAndReturnTrue() {
//            // Arrange: Setup a quote with 0 likes and get its ID
//            Long id = setupQuoteAndGetId();
//
//            // Act: Call incrementLikeCount
//            Mono<Boolean> resultMono = quoteRepository.incrementLikeCount(id);
//
//            // Assert: Check the direct result (true) and the database state change (likes=1)
//            StepVerifier.create(resultMono)
//                    .expectNext(true) // Expect true indicating success (row updated)
//                    .verifyComplete();
//
//            StepVerifier.create(findEntityById(id))
//                    .assertNext(entity -> assertThat(entity.getLikes()).isEqualTo(1))
//                    .verifyComplete();
//        }
//
//        @Test
//        @DisplayName("2. incrementLikeCount multiple times should increase likes accordingly")
//        void incrementLikeCount_whenCalledMultipleTimes_shouldIncrementLikesCorrectly() {
//            // Arrange: Setup a quote with 0 likes and get its ID
//            Long id = setupQuoteAndGetId();
//
//            // Act & Assert (Increment 1)
//            Mono<Boolean> inc1Result = quoteRepository.incrementLikeCount(id);
//            StepVerifier.create(inc1Result).expectNext(true).verifyComplete();
//            StepVerifier.create(findEntityById(id))
//                    .assertNext(entity -> assertThat(entity.getLikes()).isEqualTo(1))
//                    .verifyComplete();
//
//            // Act & Assert (Increment 2)
//            Mono<Boolean> inc2Result = quoteRepository.incrementLikeCount(id);
//            StepVerifier.create(inc2Result).expectNext(true).verifyComplete();
//            StepVerifier.create(findEntityById(id))
//                    .assertNext(entity -> assertThat(entity.getLikes()).isEqualTo(2))
//                    .verifyComplete();
//
//            // Act & Assert (Increment 3)
//            Mono<Boolean> inc3Result = quoteRepository.incrementLikeCount(id);
//            StepVerifier.create(inc3Result).expectNext(true).verifyComplete();
//            StepVerifier.create(findEntityById(id))
//                    .assertNext(entity -> assertThat(entity.getLikes()).isEqualTo(3))
//                    .verifyComplete();
//        }
//
//
//        @Test
//        @DisplayName("3. decrementLikeCount should decrease likes by 1 (when > 0) and return true")
//        void decrementLikeCount_whenLikesPositive_shouldDecrementLikesAndReturnTrue() {
//            // Arrange: Setup quote and increment likes to 1
//            Long id = setupQuoteAndGetId();
//            quoteRepository.incrementLikeCount(id).block(); // Pre-increment to 1
//
//            // Sanity check starting state
//            StepVerifier.create(findEntityById(id))
//                    .assertNext(entity -> assertThat(entity.getLikes()).isEqualTo(1))
//                    .verifyComplete();
//
//            // Act: Call decrementLikeCount
//            Mono<Boolean> resultMono = quoteRepository.decrementLikeCount(id);
//
//            // Assert: Check the direct result (true) and the database state change (likes=0)
//            StepVerifier.create(resultMono)
//                    .expectNext(true) // Expect true indicating success (row updated)
//                    .verifyComplete();
//
//            StepVerifier.create(findEntityById(id))
//                    .assertNext(entity -> assertThat(entity.getLikes()).isZero())
//                    .verifyComplete();
//        }
//
//        @Test
//        @DisplayName("4. decrementLikeCount should not decrease likes (remain 0) and return false when likes are already 0")
//        void decrementLikeCount_whenLikesZero_shouldDoNothingAndReturnFalse() {
//            // Arrange: Setup a quote with 0 likes
//            Long id = setupQuoteAndGetId();
//
//            // Act: Call decrementLikeCount
//            Mono<Boolean> resultMono = quoteRepository.decrementLikeCount(id);
//
//            // Assert: Check the direct result (false) and the database state (still 0)
//            StepVerifier.create(resultMono)
//                    .expectNext(false) // Expect false (no row updated as likes were already 0)
//                    .verifyComplete();
//
//            StepVerifier.create(findEntityById(id))
//                    .assertNext(entity -> assertThat(entity.getLikes()).isZero())
//                    .verifyComplete();
//        }
//
//        @Test
//        @DisplayName("5. incrementLikeCount should return false when quote ID does not exist")
//        void incrementLikeCount_whenIdNotFound_shouldReturnFalse() {
//            // Arrange: Define a non-existent ID
//            Long nonExistentId = 8888L;
//
//            // Act: Call incrementLikeCount with the non-existent ID
//            Mono<Boolean> resultMono = quoteRepository.incrementLikeCount(nonExistentId);
//
//            // Assert: Verify false is returned
//            StepVerifier.create(resultMono)
//                    .expectNext(false) // No rows updated
//                    .verifyComplete();
//        }
//
//        @Test
//        @DisplayName("6. decrementLikeCount should return false when quote ID does not exist")
//        void decrementLikeCount_whenIdNotFound_shouldReturnFalse() {
//            // Arrange: Define a non-existent ID
//            Long nonExistentId = 7777L;
//
//            // Act: Call decrementLikeCount with the non-existent ID
//            Mono<Boolean> resultMono = quoteRepository.decrementLikeCount(nonExistentId);
//
//            // Assert: Verify false is returned
//            StepVerifier.create(resultMono)
//                    .expectNext(false) // No rows updated
//                    .verifyComplete();
//        }
//
//        @Test
//        @DisplayName("7. incrementLikeCount should fail with IllegalArgumentException for null ID")
//        void incrementLikeCount_whenIdNull_shouldThrowIllegalArgumentException() {
//            // Arrange: ID is null
//            Long nullId = null;
//
//            // Act: Call incrementLikeCount with null ID
//            Mono<Boolean> resultMono = quoteRepository.incrementLikeCount(nullId);
//
//            // Assert: Verify IllegalArgumentException is thrown
//            StepVerifier.create(resultMono)
//                    .expectError(IllegalArgumentException.class)
//                    .verify();
//        }
//
//        @Test
//        @DisplayName("8. decrementLikeCount should fail with IllegalArgumentException for null ID")
//        void decrementLikeCount_whenIdNull_shouldThrowIllegalArgumentException() {
//            // Arrange: ID is null
//            Long nullId = null;
//
//            // Act: Call decrementLikeCount with null ID
//            Mono<Boolean> resultMono = quoteRepository.decrementLikeCount(nullId);
//
//            // Assert: Verify IllegalArgumentException is thrown
//            StepVerifier.create(resultMono)
//                    .expectError(IllegalArgumentException.class)
//                    .verify();
//        }
//    }
//
//    @Nested
//    @DisplayName("findAllQuotes() Integration Tests")
//    class FindAllQuotesTests {
//
//        @Test
//        @DisplayName("1. Should return limited quotes ordered by ID")
//        void findAllQuotes_whenQuotesExist_shouldReturnLimitedAndOrdered() {
//            // Arrange: Insert several quotes (order matters for ID assertion)
//            String provider = testProvider + "-findAll";
//            Quote q1 = insertAndRetrieve(new Quote("Author A", "Text A"), provider).block();
//            Quote q2 = insertAndRetrieve(new Quote("Author B", "Text B"), provider).block();
//            Quote q3 = insertAndRetrieve(new Quote("Author C", "Text C"), provider).block();
//            assertThat(q1).isNotNull(); assertThat(q2).isNotNull(); assertThat(q3).isNotNull();
//            int limit = 2;
//
//            // Act: Call findAllQuotes with the specified limit
//            Flux<Quote> resultFlux = quoteRepository.findAllQuotes(limit);
//
//            // Assert: Verify the first two quotes (by insertion order/ID) are returned
//            StepVerifier.create(resultFlux)
//                    .assertNext(quote -> { // Check first quote
//                        assertThat(quote.getId()).isEqualTo(q1.getId());
//                        assertThat(quote.getAuthor()).isEqualTo("Author A");
//                    })
//                    .assertNext(quote -> { // Check second quote
//                        assertThat(quote.getId()).isEqualTo(q2.getId());
//                        assertThat(quote.getAuthor()).isEqualTo("Author B");
//                    })
//                    .verifyComplete(); // verifies that only 'limit' items were emitted
//        }
//
//        @Test
//        @DisplayName("2. Should return all quotes if limit exceeds available count")
//        void findAllQuotes_whenLimitExceedsCount_shouldReturnAll() {
//            // Arrange: Insert fewer quotes (2) into the clean database than the limit we will request (5).
//            String provider = testProvider + "-findAllLimit";
//            Quote quoteA = insertAndRetrieve(new Quote("Author Lim A", "Text Lim A"), provider).block();
//            Quote quoteB = insertAndRetrieve(new Quote("Author Lim B", "Text Lim B"), provider).block();
//            assertThat(quoteA).isNotNull(); // Sanity check: setup worked
//            assertThat(quoteB).isNotNull(); // Sanity check: setup worked
//            int highLimit = 5; // Define a limit greater than the number of available quotes (2)
//
//            // Act: Execute the repository method under test with the high limit.
//            Flux<Quote> resultFlux = quoteRepository.findAllQuotes(highLimit);
//
//            // Assert: Verify that the resulting Flux contains exactly the 2 quotes
//            StepVerifier.create(resultFlux)
//                    .assertNext(quote -> { // Check first emitted quote matches quoteA
//                        assertThat(quote.getId()).isEqualTo(quoteA.getId());
//                        assertThat(quote.getAuthor()).isEqualTo(quoteA.getAuthor());
//                        assertThat(quote.getText()).isEqualTo(quoteA.getText());
//                    })
//                    .assertNext(quote -> { // Check second emitted quote matches quoteB
//                        assertThat(quote.getId()).isEqualTo(quoteB.getId());
//                        assertThat(quote.getAuthor()).isEqualTo(quoteB.getAuthor());
//                        assertThat(quote.getText()).isEqualTo(quoteB.getText());
//                    })
//                    .verifyComplete(); // Ensure the stream finishes after emitting exactly 2 items
//        }
//
//
//        @Test
//        @DisplayName("3. Should return empty Flux when no quotes exist")
//        void findAllQuotes_whenDbEmpty_shouldReturnEmptyFlux() {
//            // Arrange
//            int limit = 5;
//
//            // Act: Call findAllQuotes
//            Flux<Quote> resultFlux = quoteRepository.findAllQuotes(limit);
//
//            // Assert: Verify the Flux completes without emitting any items
//            StepVerifier.create(resultFlux)
//                    .expectNextCount(0)
//                    .verifyComplete();
//        }
//
//        @Test
//        @DisplayName("4. Should return IllegalArgumentException when limit is zero")
//        void findAllQuotes_whenLimitIsZero_shouldThrowIllegalArgumentException() {
//            // Arrange: Define zero limit
//            int zeroLimit = 0;
//
//            // Act: Call findAllQuotes
//            Flux<Quote> resultFlux = quoteRepository.findAllQuotes(zeroLimit);
//
//            // Assert: Verify the specific exception is thrown
//            StepVerifier.create(resultFlux)
//                    .expectErrorMatches(throwable -> throwable instanceof IllegalArgumentException)
//                    .verify();
//        }
//
//        @Test
//        @DisplayName("5. Should return IllegalArgumentException when limit is negative")
//        void findAllQuotes_whenLimitIsNegative_shouldThrowIllegalArgumentException() {
//            // Arrange: Define negative limit
//            int negativeLimit = -1;
//
//            // Act: Call findAllQuotes
//            Flux<Quote> resultFlux = quoteRepository.findAllQuotes(negativeLimit);
//
//            // Assert: Verify the specific exception is thrown
//            StepVerifier.create(resultFlux)
//                    .expectErrorMatches(throwable -> throwable instanceof IllegalArgumentException)
//                    .verify();
//        }
//    }
//
//    @Nested
//    @DisplayName("findRandomQuotes() Integration Tests")
//    class FindRandomQuotesTests {
//
//        @Test
//        @DisplayName("1. Should return correct number of quotes when available")
//        void findRandomQuotes_whenEnoughQuotes_shouldReturnCorrectAmount() {
//            // Arrange: Insert more quotes than requested amount
//            String provider = testProvider + "-findRandom";
//            insertAndRetrieve(new Quote("R Author 1", "R Text 1"), provider).block();
//            insertAndRetrieve(new Quote("R Author 2", "R Text 2"), provider).block();
//            insertAndRetrieve(new Quote("R Author 3", "R Text 3"), provider).block();
//            int amount = 2;
//
//            // Act: Call findRandomQuotes
//            Mono<Optional<List<Quote>>> resultMono = quoteRepository.findRandomQuotes(amount);
//
//            // Assert: Verify the Optional is present and contains a list of the requested size
//            StepVerifier.create(resultMono)
//                    .assertNext(optionalList -> {
//                        assertThat(optionalList).isPresent();
//                        assertThat(optionalList.get()).hasSize(amount);
//                        List<Long> returnedIds = optionalList.get().stream().map(Quote::getId).toList();
//                        assertThat(returnedIds).doesNotContainNull(); // Sanity check
//                    })
//                    .verifyComplete();
//        }
//
//        @Test
//        @DisplayName("2. Should return all available quotes if amount requested exceeds count")
//        void findRandomQuotes_whenAmountExceedsCount_shouldReturnAllAvailable() {
//            // Arrange: Insert fewer quotes than the requested amount
//            String provider = testProvider + "-findRandomLess";
//            Quote q1 = insertAndRetrieve(new Quote("R Less 1", "R Less 1"), provider).block();
//            Quote q2 = insertAndRetrieve(new Quote("R Less 2", "R Less 2"), provider).block();
//            assertThat(q1).isNotNull(); assertThat(q2).isNotNull();
//            int amount = 5; // Request more than available (2)
//
//            // Act: Call findRandomQuotes
//            Mono<Optional<List<Quote>>> resultMono = quoteRepository.findRandomQuotes(amount);
//
//            // Assert: Verify the Optional is present and contains all available quotes (2)
//            StepVerifier.create(resultMono)
//                    .assertNext(optionalList -> {
//                        assertThat(optionalList).isPresent();
//                        assertThat(optionalList.get()).hasSize(2); // Should contain exactly the 2 available quotes
//                    })
//                    .verifyComplete();
//        }
//
//        @Test
//        @DisplayName("3. Should return Optional of empty list when no quotes exist")
//        void findRandomQuotes_whenDbEmpty_shouldReturnOptionalOfEmptyList() {
//            // Arrange: Database is empty
//            int amount = 3;
//
//            // Act: Call findRandomQuotes
//            Mono<Optional<List<Quote>>> resultMono = quoteRepository.findRandomQuotes(amount);
//
//            // Assert: Verify the result is an Optional containing an empty list
//            StepVerifier.create(resultMono)
//                    .expectNext(Optional.of(List.of()))
//                    .verifyComplete();
//        }
//
//        @Test
//        @DisplayName("4. Should return IllegalArgumentException when amount is zero")
//        void findRandomQuotes_whenAmountIsZero_shouldThrowIllegalArgumentException() {
//            // Arrange: Define zero amount
//            int zeroAmount = 0;
//
//            // Act: Call findRandomQuotes
//            Mono<Optional<List<Quote>>> resultMono = quoteRepository.findRandomQuotes(zeroAmount);
//
//            // Assert: Verify the specific exception is thrown
//            StepVerifier.create(resultMono)
//                    .expectErrorMatches(throwable -> throwable instanceof IllegalArgumentException)
//                    .verify();
//        }
//
//        @Test
//        @DisplayName("5. Should return IllegalArgumentException when amount is negative")
//        void findRandomQuotes_whenAmountIsNegative_shouldThrowIllegalArgumentException() {
//            // Arrange: Define negative amount
//            int negativeAmount = -1;
//
//            // Act: Call findRandomQuotes
//            Mono<Optional<List<Quote>>> resultMono = quoteRepository.findRandomQuotes(negativeAmount);
//
//            // Assert: Verify the specific exception is thrown
//            StepVerifier.create(resultMono)
//                    .expectErrorMatches(throwable -> throwable instanceof IllegalArgumentException)
//                    .verify();
//        }
//    }
//
//}